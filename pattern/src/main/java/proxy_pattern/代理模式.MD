代理模式主要有三种实现的形式:
    1.静态代理
         用途:
            可以做到在不修改目标对象的功能前提下,对目标功能扩展.
         缺点:
            因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.
            同时,一旦接口增加方法,目标对象与代理对象都要维护.
    2.动态代理
        2.1 jdk的动态代理
            拿到代理对象的引用,然后获取他的接口
            jdk代理就会重新生成一个类,同时实现我们给的代理对象所实现的接口
            把被代理对象的引用也拿到了,然后通过invoke重新动态生成一个class字节码再编译
        2.2 cglib的动态代理
            自动生成一个类,继承被代理对象,然后把生成类的引用赋值给他的父类
            优点: 少写一个接口

JDK动态代理和Gglib动态代理的区别：
1.JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
2.JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低,CGLib不支持嵌套增强。
3.JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。           
        
        
注意点:代理模式关心的是过程而不是结果,还有就是动态代理并不是代理整个类,而是用到那个方法时就代理那个方法

底层:字节码重组


--------------------- 
作者：VirtiL 
原文：https://blog.csdn.net/virtiL33