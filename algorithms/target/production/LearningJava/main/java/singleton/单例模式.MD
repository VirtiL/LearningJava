5种单例模式的实现方式(推荐顺序从上向下)

EnumSingleton       枚举式
DoubleValidateLock  双重效验锁的方式
StaticInnerClass    静态内部类的方式
HungrySingleton     饿汉式
LazySingleton       懒汉式


**1.什么是单例模式?**
    单例模式，是一种常用的软件设计模式。属于创建型模式的一种,在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。
数学与逻辑学中，Singleton定义为“有且仅有一个元素的集合”。单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：“保证一个类仅有一个实例，并提供一个访问它的全局访问点。”
Java中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。”
说白了就是谁要用我,就这么一个,多了没有,少了不行.就这么不要脸!
    
**2.为什么用单例模式?**
    在写代码过程中,new起对象来那叫一个舒服,没事我就new一个,没事我就new一个,需要老婆new一个也就完事了,但是设计到一个很严重的问题,大白话就是重复数据太多了,计算机的内存就像一个水杯,A需要一滴水,他就往水杯里滴一滴,B也要用一滴水,但是他以为水杯没这个水,他也滴一滴水,依次类推,水杯早晚得溢出来,但是怎么去解决让所有人都能用到同一滴水呢.这就是单例了,所有人都用这一滴,也就解决了内存被占满的情况了,你的程序也就不会(砰~)爆了!而单例模式的目的,就是为了解决,在你的系统中只存在这有且仅有的一滴水,谁要用,拿去!想要俩,不好意思,没有!还像再滴进来一滴,不好意思,不让!
        
**3.单例模式怎么用?**
    大多数的情况下感觉new一个对象就解决问题了,也以为不会出现内存被浪费的问题,但是多线程这个玩意总是让人不省心,总是不知不觉的就给你搞点事出来,让你蛋疼,多线程一直是一个大难题,多线程下的对象安全不安全也总是被人忽略掉,虽然单例很多写法,但是书写单例模式基本都是想保证线程安全的,线程不安全的写法也没有太大意义下面我就详细介绍一下:
构建单例的方式一般有两种,也就是常说的懒汉式和饿汉式,但是这俩是什么玩意,还饱汉呢,其实在java中这两种还是有那么点味道的
3.1    懒汉式(线程不安全)
    懒嘛,也就是经常听到的什么延迟加载啊,懒加载啊之类的,就比如说我想吃棒棒糖,好,那我去买一颗棒棒糖放卧室里,想吃了,我进卧室舔一舔,想吃了,我再进卧室舔一舔,别人也想吃了,进卧室也想舔,哎呀,都被你舔了,真恶心,没说不允许买新的,我再买一个,也在屋里舔,舔的不亦乐乎(没准哪天就舔臭了,哈哈...)
懒汉式在代码中就是,我需要的时候我就创建一个对象供我使用.因为它是延迟加载的,所以并没有进行实例化,所以避免多线程资源竞争就得加上synchronized保证安全,
3.2    饿汉式(线程安全)
    饿汉,听起来就有点着急的意思,干啥事都着急,饿死鬼,吃个饭都火急火燎的,也不怕噎死!那它是什么样的呢?废话,饿汉嘛,都着急了,肯定没那么慢,更不会延迟加载,人家比较有品味嘛,但是人家还贼聪明,就是还没想吃棒棒糖的时候就已经买好棒棒糖放卧室里了,等哪天有人想吃一下啦,就进去舔一下,别人也想吃,就进去一起舔,不允许再买了!但是如果一直没人舔可就放臭了!
饿汉式在代码中就是,在虚拟机启动的时候我就创建一个对象供后续使用,因为在类加载的时候就被实例化了,所以在多线程获取时取到的都是一个,也不会发生new的情况.
    
**4.扒一扒单例的全身衣服!**
    个人感觉,饿汉式虽说是线程安全的,但是如果这个对象一直没有被使用,也是白白浪费了内存资源,单例的写法总结下来基本也就三种靠谱一点,下面咱就来扒一扒:

4.1 双重校验锁
    推荐使用懒汉式写法，即延迟加载，当需要用到实例的时候，才去初始化(new)此实例。但在并发环境下，一重判断，即判断一次instance为null，是不行的，并发环境下如果同时多个线程进入方法体就不能保证单例了，因此衍生了双重检查锁定的实现。

4.2 静态内部类
    静态内部类实现单例模式，主要原理为：Java中静态内部类可以访问其外部类的静态成员属性，同时，静态内部类只有当被调用的时候才开始首次被加载，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的;这里利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗(加synchronized同步锁)。
        
4.3 枚举
    枚举是JDK1.5中添加的,不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。相比之下，你就会发现，枚举实现单例的代码会精简很多。上面的双重锁校验的代码之所以很臃肿，是因为
大部分代码都是在保证线程安全。为了在保证线程安全和锁粒度之间做权衡，代码难免会写的复杂些。但是，4.1的代码还是有问题的，因为他无法解决反序列化会破坏单例的问题。其实，并不是使用枚举
就不需要保证线程安全，只不过线程安全的保证不需要我们关心了而已。也就是说，其实在底层还是做了线程安全方面的保证的;那么，底层到底指的是什么？

--------------------- 
作者：VirtiL 
原文：https://blog.csdn.net/virtiL33/article/details/87188896 
