@[TOC]
# 设计模式之原型模式(5)

## 什么是原型模式?

原型模式是创建型模式的一种，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。

## 为什么用原型模式?

原型模式的重点在于 **"复制"** 两个字,所以不要把原型片面的理解为创建,大家其实在平时的工作中用到过很多原型模式,对于不了解的可能压根不知道自己已经用过这个模式很多次了,比如BeanUtils.copyProperties(),再比如JSON.parseObject()等等这些都是原型模式的实现,这么实现的好处到底是什么呢?比如DTO到VO或者BO的转化,new一个对象各种get,set一直到转化完成给上下游使用,这种工作写起来易错,还费劲,而且期间还用了new关键字,那自然就需要走一遍类加载的过程,白白浪费了资源和时间,而原型模式就可以优化这个过程,它通过复制的方式复制一遍引用或者内存地址来达到目的,可以减少类的检查和权限等等所消耗的时间.所以在生产大量对象时,这个模式是个很好的选择方案.

## 原型模式怎么用?

需要实现克隆的对象,必须实现**java.lang.Cloneable**接口,这个接口就是标记一下,意思就是你实现了这个接口,那就会调用你重写的clone方法,如果没有重写clone方法但是调用了克隆,就会报找不到克隆方法的异常,重写克隆方法就可以完成复制的作用 ,先来看一下类图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210122142622788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpcnRpTDMz,size_16,color_FFFFFF,t_70)
在原型模式中有三个概念: **抽象原型** , **具体原型** ,**使用环境(客户)** 

相信大家都知道,Object是所有java类的父类,而Object中具有clone()方法,而Object就相当于是抽象原型,我们写的实现了**java.lang.Cloneable**接口的对象类就是具体原型,我们在方法(使用环境)中调用对象的clone()方法来实现克隆



在实现克隆的过程中会涉及到两个重要的概念:

### 浅克隆:

​	在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制,只是克隆了内存地址的指针引用,这个时候老对象和克隆出来的对象引用用的同一个,内存地址用的也是同一个,一改都改

​	实现浅克隆的方式就是正在重写方法中直接调用Object的clone()方法即可实现

### 深克隆:

​	在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制,那就会复制所有数据开辟一块新内存空间,把新的指针引用赋值给你创建的克隆对象,这个时候老对象和克隆出来的对象就是引用不同,内存不同,改其中某一个另一个不受影响

​	实现深克隆的方式就是重写clone()方法中通过序列化和反序列化等方式去实现,这种方式其实可以攻击单例模式



## 总结

原型模式其实知识点并不是很多,说白了就是一个复制黏贴的过程,所以在我们平时的业务需求中如果存在那种要大量创建复杂对象的时候,原型模式是一个很好的解决方案,不同于工厂模式,原型需要维护自己的克隆方法,所以也是有利有弊的,结合实际业务评估即可.最后咱们总结下优缺点

### 优点:

可以便捷的创建大量复杂对象,节省下类加载器的工作时间,可以提高创建对象的效率,而且原型模式中也是面向接口编程嘛,所以自然而言的具备可拓展的特性,同时深克隆出来的对象也可以很好的解决历史记录的问题,就像一个版本管理一样,既方便好处也不言而喻.

### 缺点:

每个具体的原型都需要重写克隆方法,并且实现自己的克隆功能,如果期间需要改变一些东西,那就需要改造这个实现,这也违背了开闭原则,在深克隆的过程中,如果引用的类型很多并且嵌套很多层,那对于实现深克隆来说会变得繁琐,嵌套的每一层都需要实现深克隆,工作量也随之加大了.





